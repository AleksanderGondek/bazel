// Copyright 2024 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.google.devtools.build.lib.skyframe.serialization.testutils;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.hash.Hashing.murmur3_128;
import static com.google.devtools.build.lib.skyframe.serialization.testutils.Dumper.computeVisitOrder;
import static com.google.devtools.build.lib.skyframe.serialization.testutils.Dumper.getTypeName;
import static java.lang.Math.min;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.devtools.build.lib.skyframe.serialization.ObjectCodecRegistry;
import com.google.devtools.build.lib.skyframe.serialization.testutils.FieldInfoCache.PrimitiveInfo;
import java.lang.ref.WeakReference;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HexFormat;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Computes fingerprints for object graph elements reached by traversing object members.
 *
 * <p>Like serialization, it skips {@code transient} fields.
 *
 * <p>An object's fingerprint is generated by recursively converting objects to strings and
 * fingerprinting those strings. Once fingerprinted, an object is referenced by its fingerprint.
 * This process works trivially for Directed Acyclic Graphs (DAGs).
 *
 * <p>Fingerprinting cycles (or Strongly Connected Components - SCCs), detected by tracking
 * references during traversal, requires a more sophisticated approach. This class employs two
 * strategies to determine a canonical root for an SCC:
 *
 * <ol>
 *   <li><b>Partial Fingerprints:</b> When an SCC is detected, partial fingerprints are constructed
 *       by omitting edges internal to the SCC. Objects within the SCC are then sorted by their
 *       partial fingerprints. The object with the lexicographically smallest <em>unique</em>
 *       partial fingerprint is selected as the traversal root. However, a unique partial
 *       fingerprint may not always exist. See {@link FingerprinterTest} for examples.
 *   <li><b>Full, Relative Fingerprints:</b> If no unique partial fingerprints exist, full
 *       fingerprints are computed relative to each element within the SCC. These are compared to
 *       identify a distinctive root. Cycle detection and backreference handling during traversal
 *       are managed by the {@link Dumper}.
 * </ol>
 *
 * <p>Once a root is determined, the canonical fingerprint for the SCC is generated by traversing
 * from the root using the {@link Dumper}. Each node within the SCC is then assigned a unique
 * identifier composed of the rooted SCC fingerprint and its traversal order.
 *
 * <p>Importantly, this root determination and identifier assignment logic is independent of the
 * starting node within the SCC. Therefore, if an identical SCC is encountered later, even if
 * traversed from a different starting node, the same identifiers will be produced.
 *
 * <p>If no distinguishable root can be determined, only the initially chosen node (potential root)
 * itself is fingerprinted. In such cases, fingerprints for other elements within the SCC are not
 * meaningful outside the context of this arbitrary root and are therefore not published. In this
 * case, if the same SCC is encountered later, but starting from a different node, the equivalence
 * will not be detected.
 */
public final class Fingerprinter implements GraphDataCollector<Fingerprinter.RepresentationSink> {
  private static final HexFormat HEX_FORMAT = HexFormat.of().withUpperCase();

  @Nullable // if present, used to lookup serialization constants
  private final ObjectCodecRegistry registry;

  /**
   * Stores a mapping from an object to its ID, usually its fingerprint.
   *
   * <p>If the object is part of an SCC, its ID will be {@code <fingerprint>[<id>]} instead.
   */
  private final IdentityHashMap<Object, String> canonicalIds = new IdentityHashMap<>();

  private int nextTraversalIndex = 0;

  /**
   * Stack for detecting cyclic backreferences in depth-first traversal.
   *
   * <p>This is basically Tarjan's SCC algorithm. The stack data is split between {@link #stack} and
   * {@link #stronglyConnectedComponent}, which additionally stores partial fingerprints.
   */
  private final IdentityHashMap<Object, Integer> stack = new IdentityHashMap<>();

  private final IdentityHashMap<Object, ElementInfo> stronglyConnectedComponent =
      new IdentityHashMap<>();

  private final RepresentationSink rootSink =
      new RepresentationSink(
          /* parent= */ null, /* parentLabel= */ null, /* descriptor= */ null, /* obj= */ null);

  /**
   * Computes a fingerprint for {@code obj} using {code registry} for reference constants if
   * provided.
   */
  public static String computeFingerprint(@Nullable ObjectCodecRegistry registry, Object obj) {
    return computeFingerprints(registry, obj).get(obj);
  }

  static IdentityHashMap<Object, String> computeFingerprints(
      @Nullable ObjectCodecRegistry registry, Object obj) {
    var collector = new Fingerprinter(registry);
    new GraphTraverser<>(registry, collector)
        .traverseObject(/* label= */ null, obj, collector.rootSink);
    collector.canonicalIds.put(
        obj, Iterables.getOnlyElement(collector.rootSink.childRepresentations));
    return collector.canonicalIds;
  }

  static IdentityHashMap<Object, String> computeFingerprints(Object obj) {
    return computeFingerprints(/* registry= */ null, obj);
  }

  private Fingerprinter(@Nullable ObjectCodecRegistry registry) {
    this.registry = registry;
  }

  final class RepresentationSink implements GraphDataCollector.Sink {
    @Nullable // null only for the root object
    private final RepresentationSink parent;

    /** Label parent uses for the child associated with this sink. */
    @Nullable private final String parentLabel;

    private final Descriptor descriptor;
    private final Object obj;

    private final ArrayList<String> childRepresentations = new ArrayList<>();

    private int lowLink = Integer.MAX_VALUE;

    private RepresentationSink(
        @Nullable RepresentationSink parent,
        @Nullable String parentLabel,
        Descriptor descriptor,
        Object obj) {
      this.parent = parent;
      this.parentLabel = parentLabel;
      this.descriptor = descriptor;
      this.obj = obj;
    }

    private void addChildRepresentation(@Nullable String label, String representation) {
      childRepresentations.add(prependLabel(label, representation));
    }

    /**
     * Registers a child that is part of the same strongly connected component as this parent.
     *
     * <p>The child's partial fingerprint should not be included here. Whether it is known at this
     * point in time depends on the traversal order. This node's partial fingerprint must remain
     * independent of traversal order for it to be used in canonicalization.
     *
     * @param childHeader the parent label concatenated with the child's descriptor
     */
    private void signalUpReference(String childHeader, int upReference) {
      childRepresentations.add(childHeader);
      lowLink = min(lowLink, upReference);
    }

    @Override
    public void completeAggregate() {
      stack.remove(obj);

      if (lowLink == descriptor.traversalIndex()) {
        // This is the top of a strongly connected component.
        handleStronglyConnectedComponent();
        return;
      }

      String fingerprint = computeFingerprint();

      if (lowLink > descriptor.traversalIndex()) {
        // This object is complete. Publishes its fingerprint and reports it to the parent.
        publishCompleteFingerprint(fingerprint);
        return;
      }

      // A child contained up references above this object. Marks this object as part of a strongly
      // connected component along with its local, partial fingerprint.
      stronglyConnectedComponent.put(obj, new ElementInfo(fingerprint, lowLink));
      if (parent != null) {
        parent.signalUpReference(prependLabel(parentLabel, descriptor.description()), lowLink);
      }
    }

    private void handleStronglyConnectedComponent() {
      var elements =
          ArrayListMultimap.<String, Object>create(
              stronglyConnectedComponent.size() + 1, /* expectedValuesPerKey= */ 3);
      String fingerprint = computeFingerprint();
      elements.put(fingerprint, obj);
      Iterator<Map.Entry<Object, ElementInfo>> entryIterator =
          stronglyConnectedComponent.entrySet().iterator();
      // Transfers objects from the `stronglyConnectedComponents` that are underneath `obj` into
      // `elements`. There can be objects in `stronglyConnectedComponents` that siblings or cousins
      // when an ancestor of `obj` belongs to a different strongly connected component.
      while (entryIterator.hasNext()) {
        Map.Entry<Object, ElementInfo> entry = entryIterator.next();
        if (entry.getValue().lowLink() >= descriptor.traversalIndex()) {
          elements.put(entry.getValue().partialFingerprint(), entry.getKey());
          entryIterator.remove();
        }
      }

      Object root = tryDetermineRoot(asSortedGroups(elements));

      if (root != null) {
        // Uses a traversal from `root` to determine a visitation order and a fingerprint for the
        // component.
        var dumpOut = new StringBuilder();
        IdentityHashMap<Object, Integer> visited =
            computeVisitOrder(registry, canonicalIds, root, dumpOut);
        String componentFingerprint = fingerprintString(dumpOut.toString());
        // Publishes fingerprints for every element of the component.
        visited.forEach(
            (value, index) ->
                canonicalIds.put(value, (componentFingerprint + '[' + index + ']').intern()));
        if (parent != null) {
          parent.addChildRepresentation(
              parentLabel, (componentFingerprint + '[' + visited.get(obj) + ']').intern());
        }
        return;
      }

      // Falls back on treating the entire component as an aggregate. This allows deduplication when
      // the aggregate is encountered starting from the `obj` as the root. However, it is vulnerable
      // to the case where the same component is referenced starting from a different root. In that
      // case, fingerprinting will not detect the equivalence.
      //
      // It's unlikely for production data to have this much symmetry.
      var dumpOut = new StringBuilder();
      var unused = computeVisitOrder(registry, canonicalIds, obj, dumpOut);
      publishCompleteFingerprint(fingerprintString(dumpOut.toString()));
    }

    /**
     * Computes a fingerprint.
     *
     * <p>This is partial if {@link #obj} is part of a strongly connected component.
     */
    private String computeFingerprint() {
      String representation =
          descriptor.description() + ": [" + String.join(", ", childRepresentations) + ']';
      return fingerprintString(representation);
    }

    private void publishCompleteFingerprint(String fingerprint) {
      canonicalIds.put(obj, fingerprint);
      if (parent != null) {
        parent.addChildRepresentation(parentLabel, fingerprint);
      }
    }
  }

  @Override
  public void outputNull(@Nullable String label, RepresentationSink sink) {
    sink.addChildRepresentation(label, "null");
  }

  @Override
  public void outputSerializationConstant(
      @Nullable String label, Class<?> type, int tag, RepresentationSink sink) {
    String representation = getTypeName(type) + "[SERIALIZATION_CONSTANT:" + tag + ']';
    sink.addChildRepresentation(label, representation);
  }

  @Override
  public void outputWeakReference(@Nullable String label, RepresentationSink sink) {
    sink.addChildRepresentation(label, WeakReference.class.getCanonicalName());
  }

  @Override
  public void outputInlineObject(
      @Nullable String label, Class<?> type, Object obj, RepresentationSink sink) {
    // Emits the type, even for inline values. This avoids a possible ambiguities. For example, "-1"
    // could be a backreference, String, Integer, or other things if there were no type prefix.
    sink.addChildRepresentation(label, getTypeName(type) + ':' + obj);
  }

  @Override
  public void outputPrimitive(PrimitiveInfo info, Object parent, RepresentationSink sink) {
    sink.addChildRepresentation(info.name() + '=', info.getText(parent));
  }

  @Override
  @Nullable
  public Descriptor checkCache(
      @Nullable String label, Class<?> type, Object obj, RepresentationSink sink) {
    String representation = canonicalIds.get(obj);
    if (representation != null) {
      sink.addChildRepresentation(label, representation);
      return null;
    }

    String description = getTypeName(type);

    ElementInfo info = stronglyConnectedComponent.get(obj);
    if (info != null) {
      sink.signalUpReference(prependLabel(label, description), info.lowLink);
      return null;
    }

    Integer previousDepth = stack.putIfAbsent(obj, nextTraversalIndex);
    if (previousDepth != null) {
      sink.signalUpReference(prependLabel(label, description), previousDepth);
      return null;
    }

    // There's nothing cached. Returns a descriptor.
    return new Descriptor(description, nextTraversalIndex++);
  }

  @Override
  public void outputByteArray(
      @Nullable String label, Descriptor descriptor, byte[] bytes, RepresentationSink sink) {
    String representation = descriptor.description() + ": [" + HEX_FORMAT.formatHex(bytes) + ']';
    String fingerprint = fingerprintString(representation);
    canonicalIds.put(bytes, fingerprint);
    sink.addChildRepresentation(label, fingerprint);
  }

  @Override
  public void outputInlineArray(
      @Nullable String label, Descriptor descriptor, Object arr, RepresentationSink sink) {
    StringBuilder representation = new StringBuilder(descriptor.description()).append(": [");
    int length = Array.getLength(arr);
    for (int i = 0; i < length; i++) {
      if (i > 0) {
        representation.append(", ");
      }
      Object elt = Array.get(arr, i);
      if (elt != null) {
        representation.append(getTypeName(elt.getClass())).append(':');
      }
      representation.append(elt);
    }
    representation.append(']');
    String fingerprint = fingerprintString(representation.toString());
    canonicalIds.put(arr, fingerprint);
    sink.addChildRepresentation(label, fingerprint);
  }

  @Override
  public void outputEmptyAggregate(
      @Nullable String label, Descriptor descriptor, Object obj, RepresentationSink sink) {
    String representation = descriptor.description() + " []";
    String fingerprint = fingerprintString(representation.toString());
    canonicalIds.put(obj, fingerprint);
    sink.addChildRepresentation(label, fingerprint);
  }

  @Override
  public RepresentationSink initAggregate(
      @Nullable String label, Descriptor descriptor, Object obj, RepresentationSink parent) {
    return new RepresentationSink(parent, label, descriptor, obj);
  }

  /**
   * Information collected about nodes in a strongly connected component.
   *
   * @param partialFingerprint a partial description of a strongly connected component element,
   *     omitting information about any nodes that are strongly connected.
   * @param lowLink strongly connected components are detected by seeing references up the stack
   *     during depth first search. This value is the minimum stack depth referenced by this node or
   *     any of its descendants.
   */
  record ElementInfo(String partialFingerprint, int lowLink) {}

  @Nullable
  private Object tryDetermineRoot(ImmutableList<Map.Entry<String, Collection<Object>>> groups) {
    Collection<Object> firstValue = groups.get(0).getValue();
    if (firstValue.size() == 1) {
      // Partial fingerprints were enough to determine a unique root.
      return firstValue.iterator().next();
    }

    // Since the entries are sorted by group size, every remaining entry has size > 1.
    // Attempts to split groups by full dump.

    for (Map.Entry<String, Collection<Object>> entry : groups) {
      // The elements in the group are indistinguishable by partial fingerprint. Uses a full dump
      // to create fingerprints instead.
      var elements = ArrayListMultimap.<String, Object>create();
      for (Object obj : entry.getValue()) {
        var dumpOut = new StringBuilder();
        var unused = computeVisitOrder(registry, canonicalIds, obj, dumpOut);
        elements.put(fingerprintString(dumpOut.toString()), obj);
      }
      ImmutableList<Map.Entry<String, Collection<Object>>> refinedGroups = asSortedGroups(elements);
      firstValue = refinedGroups.get(0).getValue();
      if (firstValue.size() == 1) {
        return firstValue.iterator().next();
      }
    }

    // All the groups were of size greater than one and none of them could be split by full
    // fingerprinting. This may occur for perfectly symmetrical object graphs.
    return null;
  }

  /**
   * Comparator that orders groups of elements having the same fingerprint.
   *
   * <p>First orders by group size, then by the fingerprint value.
   */
  private static final Comparator<Map.Entry<String, Collection<Object>>>
      FINGERPRINT_GROUP_COMPARATOR =
          Comparator.<Map.Entry<String, Collection<Object>>, Integer>comparing(
                  entry -> entry.getValue().size())
              .thenComparing(entry -> entry.getKey());

  private static ImmutableList<Map.Entry<String, Collection<Object>>> asSortedGroups(
      ArrayListMultimap<String, Object> objectsByFingerprint) {
    return objectsByFingerprint.asMap().entrySet().stream()
        .sorted(FINGERPRINT_GROUP_COMPARATOR)
        .collect(toImmutableList());
  }

  private static String prependLabel(@Nullable String label, String description) {
    return label == null ? description : label + description;
  }

  @VisibleForTesting
  static String fingerprintString(String text) {
    // Dumper relies on reference equality of these strings.
    return murmur3_128().hashUnencodedChars(text).toString().intern();
  }
}
